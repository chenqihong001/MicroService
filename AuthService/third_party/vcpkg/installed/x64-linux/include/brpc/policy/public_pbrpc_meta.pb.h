// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: brpc/policy/public_pbrpc_meta.proto
// Protobuf C++ Version: 4.25.1

#ifndef GOOGLE_PROTOBUF_INCLUDED_brpc_2fpolicy_2fpublic_5fpbrpc_5fmeta_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_brpc_2fpolicy_2fpublic_5fpbrpc_5fmeta_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025001 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_brpc_2fpolicy_2fpublic_5fpbrpc_5fmeta_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_brpc_2fpolicy_2fpublic_5fpbrpc_5fmeta_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_brpc_2fpolicy_2fpublic_5fpbrpc_5fmeta_2eproto;
namespace brpc {
namespace policy {
class PublicPbrpcRequest;
struct PublicPbrpcRequestDefaultTypeInternal;
extern PublicPbrpcRequestDefaultTypeInternal _PublicPbrpcRequest_default_instance_;
class PublicPbrpcResponse;
struct PublicPbrpcResponseDefaultTypeInternal;
extern PublicPbrpcResponseDefaultTypeInternal _PublicPbrpcResponse_default_instance_;
class RequestBody;
struct RequestBodyDefaultTypeInternal;
extern RequestBodyDefaultTypeInternal _RequestBody_default_instance_;
class RequestHead;
struct RequestHeadDefaultTypeInternal;
extern RequestHeadDefaultTypeInternal _RequestHead_default_instance_;
class ResponseBody;
struct ResponseBodyDefaultTypeInternal;
extern ResponseBodyDefaultTypeInternal _ResponseBody_default_instance_;
class ResponseHead;
struct ResponseHeadDefaultTypeInternal;
extern ResponseHeadDefaultTypeInternal _ResponseHead_default_instance_;
}  // namespace policy
}  // namespace brpc
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace brpc {
namespace policy {

// ===================================================================


// -------------------------------------------------------------------

class ResponseHead final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:brpc.policy.ResponseHead) */ {
 public:
  inline ResponseHead() : ResponseHead(nullptr) {}
  ~ResponseHead() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ResponseHead(::google::protobuf::internal::ConstantInitialized);

  inline ResponseHead(const ResponseHead& from)
      : ResponseHead(nullptr, from) {}
  ResponseHead(ResponseHead&& from) noexcept
    : ResponseHead() {
    *this = ::std::move(from);
  }

  inline ResponseHead& operator=(const ResponseHead& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResponseHead& operator=(ResponseHead&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResponseHead& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResponseHead* internal_default_instance() {
    return reinterpret_cast<const ResponseHead*>(
               &_ResponseHead_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ResponseHead& a, ResponseHead& b) {
    a.Swap(&b);
  }
  inline void Swap(ResponseHead* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResponseHead* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResponseHead* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResponseHead>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ResponseHead& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ResponseHead& from) {
    ResponseHead::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ResponseHead* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "brpc.policy.ResponseHead";
  }
  protected:
  explicit ResponseHead(::google::protobuf::Arena* arena);
  ResponseHead(::google::protobuf::Arena* arena, const ResponseHead& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTextFieldNumber = 2,
    kFromHostFieldNumber = 3,
    kCodeFieldNumber = 1,
    kCompressTypeFieldNumber = 4,
  };
  // optional string text = 2;
  bool has_text() const;
  void clear_text() ;
  const std::string& text() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_text(Arg_&& arg, Args_... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* value);

  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(
      const std::string& value);
  std::string* _internal_mutable_text();

  public:
  // optional string from_host = 3;
  bool has_from_host() const;
  void clear_from_host() ;
  const std::string& from_host() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_from_host(Arg_&& arg, Args_... args);
  std::string* mutable_from_host();
  PROTOBUF_NODISCARD std::string* release_from_host();
  void set_allocated_from_host(std::string* value);

  private:
  const std::string& _internal_from_host() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_from_host(
      const std::string& value);
  std::string* _internal_mutable_from_host();

  public:
  // required sint32 code = 1;
  bool has_code() const;
  void clear_code() ;
  ::int32_t code() const;
  void set_code(::int32_t value);

  private:
  ::int32_t _internal_code() const;
  void _internal_set_code(::int32_t value);

  public:
  // optional uint32 compress_type = 4;
  bool has_compress_type() const;
  void clear_compress_type() ;
  ::uint32_t compress_type() const;
  void set_compress_type(::uint32_t value);

  private:
  ::uint32_t _internal_compress_type() const;
  void _internal_set_compress_type(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:brpc.policy.ResponseHead)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      46, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr text_;
    ::google::protobuf::internal::ArenaStringPtr from_host_;
    ::int32_t code_;
    ::uint32_t compress_type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_brpc_2fpolicy_2fpublic_5fpbrpc_5fmeta_2eproto;
};// -------------------------------------------------------------------

class ResponseBody final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:brpc.policy.ResponseBody) */ {
 public:
  inline ResponseBody() : ResponseBody(nullptr) {}
  ~ResponseBody() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ResponseBody(::google::protobuf::internal::ConstantInitialized);

  inline ResponseBody(const ResponseBody& from)
      : ResponseBody(nullptr, from) {}
  ResponseBody(ResponseBody&& from) noexcept
    : ResponseBody() {
    *this = ::std::move(from);
  }

  inline ResponseBody& operator=(const ResponseBody& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResponseBody& operator=(ResponseBody&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResponseBody& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResponseBody* internal_default_instance() {
    return reinterpret_cast<const ResponseBody*>(
               &_ResponseBody_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ResponseBody& a, ResponseBody& b) {
    a.Swap(&b);
  }
  inline void Swap(ResponseBody* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResponseBody* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResponseBody* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResponseBody>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ResponseBody& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ResponseBody& from) {
    ResponseBody::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ResponseBody* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "brpc.policy.ResponseBody";
  }
  protected:
  explicit ResponseBody(::google::protobuf::Arena* arena);
  ResponseBody(::google::protobuf::Arena* arena, const ResponseBody& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSerializedResponseFieldNumber = 1,
    kVersionFieldNumber = 2,
    kIdFieldNumber = 4,
    kErrorFieldNumber = 3,
  };
  // optional bytes serialized_response = 1;
  bool has_serialized_response() const;
  void clear_serialized_response() ;
  const std::string& serialized_response() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_serialized_response(Arg_&& arg, Args_... args);
  std::string* mutable_serialized_response();
  PROTOBUF_NODISCARD std::string* release_serialized_response();
  void set_allocated_serialized_response(std::string* value);

  private:
  const std::string& _internal_serialized_response() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_serialized_response(
      const std::string& value);
  std::string* _internal_mutable_serialized_response();

  public:
  // optional string version = 2;
  bool has_version() const;
  void clear_version() ;
  const std::string& version() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_version(Arg_&& arg, Args_... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* value);

  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(
      const std::string& value);
  std::string* _internal_mutable_version();

  public:
  // required uint64 id = 4;
  bool has_id() const;
  void clear_id() ;
  ::uint64_t id() const;
  void set_id(::uint64_t value);

  private:
  ::uint64_t _internal_id() const;
  void _internal_set_id(::uint64_t value);

  public:
  // optional int32 error = 3;
  bool has_error() const;
  void clear_error() ;
  ::int32_t error() const;
  void set_error(::int32_t value);

  private:
  ::int32_t _internal_error() const;
  void _internal_set_error(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:brpc.policy.ResponseBody)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      40, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr serialized_response_;
    ::google::protobuf::internal::ArenaStringPtr version_;
    ::uint64_t id_;
    ::int32_t error_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_brpc_2fpolicy_2fpublic_5fpbrpc_5fmeta_2eproto;
};// -------------------------------------------------------------------

class RequestHead final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:brpc.policy.RequestHead) */ {
 public:
  inline RequestHead() : RequestHead(nullptr) {}
  ~RequestHead() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RequestHead(::google::protobuf::internal::ConstantInitialized);

  inline RequestHead(const RequestHead& from)
      : RequestHead(nullptr, from) {}
  RequestHead(RequestHead&& from) noexcept
    : RequestHead() {
    *this = ::std::move(from);
  }

  inline RequestHead& operator=(const RequestHead& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestHead& operator=(RequestHead&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestHead& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestHead* internal_default_instance() {
    return reinterpret_cast<const RequestHead*>(
               &_RequestHead_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(RequestHead& a, RequestHead& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestHead* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestHead* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestHead* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestHead>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RequestHead& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RequestHead& from) {
    RequestHead::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RequestHead* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "brpc.policy.RequestHead";
  }
  protected:
  explicit RequestHead(::google::protobuf::Arena* arena);
  RequestHead(::google::protobuf::Arena* arena, const RequestHead& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFromHostFieldNumber = 1,
    kCharsetFieldNumber = 4,
    kAcceptCharsetFieldNumber = 5,
    kCreateTimeFieldNumber = 6,
    kContentTypeFieldNumber = 2,
    kConnectionFieldNumber = 3,
    kLogIdFieldNumber = 7,
    kCompressTypeFieldNumber = 8,
  };
  // optional string from_host = 1;
  bool has_from_host() const;
  void clear_from_host() ;
  const std::string& from_host() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_from_host(Arg_&& arg, Args_... args);
  std::string* mutable_from_host();
  PROTOBUF_NODISCARD std::string* release_from_host();
  void set_allocated_from_host(std::string* value);

  private:
  const std::string& _internal_from_host() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_from_host(
      const std::string& value);
  std::string* _internal_mutable_from_host();

  public:
  // optional string charset = 4;
  bool has_charset() const;
  void clear_charset() ;
  const std::string& charset() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_charset(Arg_&& arg, Args_... args);
  std::string* mutable_charset();
  PROTOBUF_NODISCARD std::string* release_charset();
  void set_allocated_charset(std::string* value);

  private:
  const std::string& _internal_charset() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_charset(
      const std::string& value);
  std::string* _internal_mutable_charset();

  public:
  // optional string accept_charset = 5;
  bool has_accept_charset() const;
  void clear_accept_charset() ;
  const std::string& accept_charset() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_accept_charset(Arg_&& arg, Args_... args);
  std::string* mutable_accept_charset();
  PROTOBUF_NODISCARD std::string* release_accept_charset();
  void set_allocated_accept_charset(std::string* value);

  private:
  const std::string& _internal_accept_charset() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_accept_charset(
      const std::string& value);
  std::string* _internal_mutable_accept_charset();

  public:
  // optional string create_time = 6;
  bool has_create_time() const;
  void clear_create_time() ;
  const std::string& create_time() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_create_time(Arg_&& arg, Args_... args);
  std::string* mutable_create_time();
  PROTOBUF_NODISCARD std::string* release_create_time();
  void set_allocated_create_time(std::string* value);

  private:
  const std::string& _internal_create_time() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_create_time(
      const std::string& value);
  std::string* _internal_mutable_create_time();

  public:
  // optional uint32 content_type = 2;
  bool has_content_type() const;
  void clear_content_type() ;
  ::uint32_t content_type() const;
  void set_content_type(::uint32_t value);

  private:
  ::uint32_t _internal_content_type() const;
  void _internal_set_content_type(::uint32_t value);

  public:
  // optional bool connection = 3;
  bool has_connection() const;
  void clear_connection() ;
  bool connection() const;
  void set_connection(bool value);

  private:
  bool _internal_connection() const;
  void _internal_set_connection(bool value);

  public:
  // optional uint64 log_id = 7;
  bool has_log_id() const;
  void clear_log_id() ;
  ::uint64_t log_id() const;
  void set_log_id(::uint64_t value);

  private:
  ::uint64_t _internal_log_id() const;
  void _internal_set_log_id(::uint64_t value);

  public:
  // optional uint32 compress_type = 8;
  bool has_compress_type() const;
  void clear_compress_type() ;
  ::uint32_t compress_type() const;
  void set_compress_type(::uint32_t value);

  private:
  ::uint32_t _internal_compress_type() const;
  void _internal_set_compress_type(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:brpc.policy.RequestHead)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 8, 0,
      81, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr from_host_;
    ::google::protobuf::internal::ArenaStringPtr charset_;
    ::google::protobuf::internal::ArenaStringPtr accept_charset_;
    ::google::protobuf::internal::ArenaStringPtr create_time_;
    ::uint32_t content_type_;
    bool connection_;
    ::uint64_t log_id_;
    ::uint32_t compress_type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_brpc_2fpolicy_2fpublic_5fpbrpc_5fmeta_2eproto;
};// -------------------------------------------------------------------

class RequestBody final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:brpc.policy.RequestBody) */ {
 public:
  inline RequestBody() : RequestBody(nullptr) {}
  ~RequestBody() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RequestBody(::google::protobuf::internal::ConstantInitialized);

  inline RequestBody(const RequestBody& from)
      : RequestBody(nullptr, from) {}
  RequestBody(RequestBody&& from) noexcept
    : RequestBody() {
    *this = ::std::move(from);
  }

  inline RequestBody& operator=(const RequestBody& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestBody& operator=(RequestBody&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestBody& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestBody* internal_default_instance() {
    return reinterpret_cast<const RequestBody*>(
               &_RequestBody_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(RequestBody& a, RequestBody& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestBody* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestBody* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestBody* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestBody>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RequestBody& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RequestBody& from) {
    RequestBody::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RequestBody* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "brpc.policy.RequestBody";
  }
  protected:
  explicit RequestBody(::google::protobuf::Arena* arena);
  RequestBody(::google::protobuf::Arena* arena, const RequestBody& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVersionFieldNumber = 1,
    kCharsetFieldNumber = 2,
    kServiceFieldNumber = 3,
    kSerializedRequestFieldNumber = 6,
    kIdFieldNumber = 5,
    kMethodIdFieldNumber = 4,
  };
  // optional string version = 1;
  bool has_version() const;
  void clear_version() ;
  const std::string& version() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_version(Arg_&& arg, Args_... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* value);

  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(
      const std::string& value);
  std::string* _internal_mutable_version();

  public:
  // optional string charset = 2;
  bool has_charset() const;
  void clear_charset() ;
  const std::string& charset() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_charset(Arg_&& arg, Args_... args);
  std::string* mutable_charset();
  PROTOBUF_NODISCARD std::string* release_charset();
  void set_allocated_charset(std::string* value);

  private:
  const std::string& _internal_charset() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_charset(
      const std::string& value);
  std::string* _internal_mutable_charset();

  public:
  // required string service = 3;
  bool has_service() const;
  void clear_service() ;
  const std::string& service() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_service(Arg_&& arg, Args_... args);
  std::string* mutable_service();
  PROTOBUF_NODISCARD std::string* release_service();
  void set_allocated_service(std::string* value);

  private:
  const std::string& _internal_service() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_service(
      const std::string& value);
  std::string* _internal_mutable_service();

  public:
  // optional bytes serialized_request = 6;
  bool has_serialized_request() const;
  void clear_serialized_request() ;
  const std::string& serialized_request() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_serialized_request(Arg_&& arg, Args_... args);
  std::string* mutable_serialized_request();
  PROTOBUF_NODISCARD std::string* release_serialized_request();
  void set_allocated_serialized_request(std::string* value);

  private:
  const std::string& _internal_serialized_request() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_serialized_request(
      const std::string& value);
  std::string* _internal_mutable_serialized_request();

  public:
  // required uint64 id = 5;
  bool has_id() const;
  void clear_id() ;
  ::uint64_t id() const;
  void set_id(::uint64_t value);

  private:
  ::uint64_t _internal_id() const;
  void _internal_set_id(::uint64_t value);

  public:
  // required uint32 method_id = 4;
  bool has_method_id() const;
  void clear_method_id() ;
  ::uint32_t method_id() const;
  void set_method_id(::uint32_t value);

  private:
  ::uint32_t _internal_method_id() const;
  void _internal_set_method_id(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:brpc.policy.RequestBody)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 0,
      53, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr version_;
    ::google::protobuf::internal::ArenaStringPtr charset_;
    ::google::protobuf::internal::ArenaStringPtr service_;
    ::google::protobuf::internal::ArenaStringPtr serialized_request_;
    ::uint64_t id_;
    ::uint32_t method_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_brpc_2fpolicy_2fpublic_5fpbrpc_5fmeta_2eproto;
};// -------------------------------------------------------------------

class PublicPbrpcResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:brpc.policy.PublicPbrpcResponse) */ {
 public:
  inline PublicPbrpcResponse() : PublicPbrpcResponse(nullptr) {}
  ~PublicPbrpcResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PublicPbrpcResponse(::google::protobuf::internal::ConstantInitialized);

  inline PublicPbrpcResponse(const PublicPbrpcResponse& from)
      : PublicPbrpcResponse(nullptr, from) {}
  PublicPbrpcResponse(PublicPbrpcResponse&& from) noexcept
    : PublicPbrpcResponse() {
    *this = ::std::move(from);
  }

  inline PublicPbrpcResponse& operator=(const PublicPbrpcResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PublicPbrpcResponse& operator=(PublicPbrpcResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PublicPbrpcResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const PublicPbrpcResponse* internal_default_instance() {
    return reinterpret_cast<const PublicPbrpcResponse*>(
               &_PublicPbrpcResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(PublicPbrpcResponse& a, PublicPbrpcResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(PublicPbrpcResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PublicPbrpcResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PublicPbrpcResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PublicPbrpcResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PublicPbrpcResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const PublicPbrpcResponse& from) {
    PublicPbrpcResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PublicPbrpcResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "brpc.policy.PublicPbrpcResponse";
  }
  protected:
  explicit PublicPbrpcResponse(::google::protobuf::Arena* arena);
  PublicPbrpcResponse(::google::protobuf::Arena* arena, const PublicPbrpcResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResponseBodyFieldNumber = 2,
    kResponseHeadFieldNumber = 1,
  };
  // repeated .brpc.policy.ResponseBody responseBody = 2;
  int responsebody_size() const;
  private:
  int _internal_responsebody_size() const;

  public:
  void clear_responsebody() ;
  ::brpc::policy::ResponseBody* mutable_responsebody(int index);
  ::google::protobuf::RepeatedPtrField< ::brpc::policy::ResponseBody >*
      mutable_responsebody();
  private:
  const ::google::protobuf::RepeatedPtrField<::brpc::policy::ResponseBody>& _internal_responsebody() const;
  ::google::protobuf::RepeatedPtrField<::brpc::policy::ResponseBody>* _internal_mutable_responsebody();
  public:
  const ::brpc::policy::ResponseBody& responsebody(int index) const;
  ::brpc::policy::ResponseBody* add_responsebody();
  const ::google::protobuf::RepeatedPtrField< ::brpc::policy::ResponseBody >&
      responsebody() const;
  // optional .brpc.policy.ResponseHead responseHead = 1;
  bool has_responsehead() const;
  void clear_responsehead() ;
  const ::brpc::policy::ResponseHead& responsehead() const;
  PROTOBUF_NODISCARD ::brpc::policy::ResponseHead* release_responsehead();
  ::brpc::policy::ResponseHead* mutable_responsehead();
  void set_allocated_responsehead(::brpc::policy::ResponseHead* value);
  void unsafe_arena_set_allocated_responsehead(::brpc::policy::ResponseHead* value);
  ::brpc::policy::ResponseHead* unsafe_arena_release_responsehead();

  private:
  const ::brpc::policy::ResponseHead& _internal_responsehead() const;
  ::brpc::policy::ResponseHead* _internal_mutable_responsehead();

  public:
  // @@protoc_insertion_point(class_scope:brpc.policy.PublicPbrpcResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::brpc::policy::ResponseBody > responsebody_;
    ::brpc::policy::ResponseHead* responsehead_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_brpc_2fpolicy_2fpublic_5fpbrpc_5fmeta_2eproto;
};// -------------------------------------------------------------------

class PublicPbrpcRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:brpc.policy.PublicPbrpcRequest) */ {
 public:
  inline PublicPbrpcRequest() : PublicPbrpcRequest(nullptr) {}
  ~PublicPbrpcRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PublicPbrpcRequest(::google::protobuf::internal::ConstantInitialized);

  inline PublicPbrpcRequest(const PublicPbrpcRequest& from)
      : PublicPbrpcRequest(nullptr, from) {}
  PublicPbrpcRequest(PublicPbrpcRequest&& from) noexcept
    : PublicPbrpcRequest() {
    *this = ::std::move(from);
  }

  inline PublicPbrpcRequest& operator=(const PublicPbrpcRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PublicPbrpcRequest& operator=(PublicPbrpcRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PublicPbrpcRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PublicPbrpcRequest* internal_default_instance() {
    return reinterpret_cast<const PublicPbrpcRequest*>(
               &_PublicPbrpcRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(PublicPbrpcRequest& a, PublicPbrpcRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PublicPbrpcRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PublicPbrpcRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PublicPbrpcRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PublicPbrpcRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PublicPbrpcRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const PublicPbrpcRequest& from) {
    PublicPbrpcRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PublicPbrpcRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "brpc.policy.PublicPbrpcRequest";
  }
  protected:
  explicit PublicPbrpcRequest(::google::protobuf::Arena* arena);
  PublicPbrpcRequest(::google::protobuf::Arena* arena, const PublicPbrpcRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestBodyFieldNumber = 2,
    kRequestHeadFieldNumber = 1,
  };
  // repeated .brpc.policy.RequestBody requestBody = 2;
  int requestbody_size() const;
  private:
  int _internal_requestbody_size() const;

  public:
  void clear_requestbody() ;
  ::brpc::policy::RequestBody* mutable_requestbody(int index);
  ::google::protobuf::RepeatedPtrField< ::brpc::policy::RequestBody >*
      mutable_requestbody();
  private:
  const ::google::protobuf::RepeatedPtrField<::brpc::policy::RequestBody>& _internal_requestbody() const;
  ::google::protobuf::RepeatedPtrField<::brpc::policy::RequestBody>* _internal_mutable_requestbody();
  public:
  const ::brpc::policy::RequestBody& requestbody(int index) const;
  ::brpc::policy::RequestBody* add_requestbody();
  const ::google::protobuf::RepeatedPtrField< ::brpc::policy::RequestBody >&
      requestbody() const;
  // optional .brpc.policy.RequestHead requestHead = 1;
  bool has_requesthead() const;
  void clear_requesthead() ;
  const ::brpc::policy::RequestHead& requesthead() const;
  PROTOBUF_NODISCARD ::brpc::policy::RequestHead* release_requesthead();
  ::brpc::policy::RequestHead* mutable_requesthead();
  void set_allocated_requesthead(::brpc::policy::RequestHead* value);
  void unsafe_arena_set_allocated_requesthead(::brpc::policy::RequestHead* value);
  ::brpc::policy::RequestHead* unsafe_arena_release_requesthead();

  private:
  const ::brpc::policy::RequestHead& _internal_requesthead() const;
  ::brpc::policy::RequestHead* _internal_mutable_requesthead();

  public:
  // @@protoc_insertion_point(class_scope:brpc.policy.PublicPbrpcRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::brpc::policy::RequestBody > requestbody_;
    ::brpc::policy::RequestHead* requesthead_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_brpc_2fpolicy_2fpublic_5fpbrpc_5fmeta_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// PublicPbrpcRequest

// optional .brpc.policy.RequestHead requestHead = 1;
inline bool PublicPbrpcRequest::has_requesthead() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.requesthead_ != nullptr);
  return value;
}
inline void PublicPbrpcRequest::clear_requesthead() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.requesthead_ != nullptr) _impl_.requesthead_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::brpc::policy::RequestHead& PublicPbrpcRequest::_internal_requesthead() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::brpc::policy::RequestHead* p = _impl_.requesthead_;
  return p != nullptr ? *p : reinterpret_cast<const ::brpc::policy::RequestHead&>(::brpc::policy::_RequestHead_default_instance_);
}
inline const ::brpc::policy::RequestHead& PublicPbrpcRequest::requesthead() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:brpc.policy.PublicPbrpcRequest.requestHead)
  return _internal_requesthead();
}
inline void PublicPbrpcRequest::unsafe_arena_set_allocated_requesthead(::brpc::policy::RequestHead* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.requesthead_);
  }
  _impl_.requesthead_ = reinterpret_cast<::brpc::policy::RequestHead*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:brpc.policy.PublicPbrpcRequest.requestHead)
}
inline ::brpc::policy::RequestHead* PublicPbrpcRequest::release_requesthead() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::brpc::policy::RequestHead* released = _impl_.requesthead_;
  _impl_.requesthead_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::brpc::policy::RequestHead* PublicPbrpcRequest::unsafe_arena_release_requesthead() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:brpc.policy.PublicPbrpcRequest.requestHead)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::brpc::policy::RequestHead* temp = _impl_.requesthead_;
  _impl_.requesthead_ = nullptr;
  return temp;
}
inline ::brpc::policy::RequestHead* PublicPbrpcRequest::_internal_mutable_requesthead() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.requesthead_ == nullptr) {
    auto* p = CreateMaybeMessage<::brpc::policy::RequestHead>(GetArena());
    _impl_.requesthead_ = reinterpret_cast<::brpc::policy::RequestHead*>(p);
  }
  return _impl_.requesthead_;
}
inline ::brpc::policy::RequestHead* PublicPbrpcRequest::mutable_requesthead() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::brpc::policy::RequestHead* _msg = _internal_mutable_requesthead();
  // @@protoc_insertion_point(field_mutable:brpc.policy.PublicPbrpcRequest.requestHead)
  return _msg;
}
inline void PublicPbrpcRequest::set_allocated_requesthead(::brpc::policy::RequestHead* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::brpc::policy::RequestHead*>(_impl_.requesthead_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::brpc::policy::RequestHead*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.requesthead_ = reinterpret_cast<::brpc::policy::RequestHead*>(value);
  // @@protoc_insertion_point(field_set_allocated:brpc.policy.PublicPbrpcRequest.requestHead)
}

// repeated .brpc.policy.RequestBody requestBody = 2;
inline int PublicPbrpcRequest::_internal_requestbody_size() const {
  return _internal_requestbody().size();
}
inline int PublicPbrpcRequest::requestbody_size() const {
  return _internal_requestbody_size();
}
inline void PublicPbrpcRequest::clear_requestbody() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.requestbody_.Clear();
}
inline ::brpc::policy::RequestBody* PublicPbrpcRequest::mutable_requestbody(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:brpc.policy.PublicPbrpcRequest.requestBody)
  return _internal_mutable_requestbody()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::brpc::policy::RequestBody>* PublicPbrpcRequest::mutable_requestbody()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:brpc.policy.PublicPbrpcRequest.requestBody)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_requestbody();
}
inline const ::brpc::policy::RequestBody& PublicPbrpcRequest::requestbody(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:brpc.policy.PublicPbrpcRequest.requestBody)
  return _internal_requestbody().Get(index);
}
inline ::brpc::policy::RequestBody* PublicPbrpcRequest::add_requestbody() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::brpc::policy::RequestBody* _add = _internal_mutable_requestbody()->Add();
  // @@protoc_insertion_point(field_add:brpc.policy.PublicPbrpcRequest.requestBody)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::brpc::policy::RequestBody>& PublicPbrpcRequest::requestbody() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:brpc.policy.PublicPbrpcRequest.requestBody)
  return _internal_requestbody();
}
inline const ::google::protobuf::RepeatedPtrField<::brpc::policy::RequestBody>&
PublicPbrpcRequest::_internal_requestbody() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.requestbody_;
}
inline ::google::protobuf::RepeatedPtrField<::brpc::policy::RequestBody>*
PublicPbrpcRequest::_internal_mutable_requestbody() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.requestbody_;
}

// -------------------------------------------------------------------

// RequestHead

// optional string from_host = 1;
inline bool RequestHead::has_from_host() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void RequestHead::clear_from_host() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.from_host_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RequestHead::from_host() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:brpc.policy.RequestHead.from_host)
  return _internal_from_host();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RequestHead::set_from_host(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.from_host_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:brpc.policy.RequestHead.from_host)
}
inline std::string* RequestHead::mutable_from_host() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_from_host();
  // @@protoc_insertion_point(field_mutable:brpc.policy.RequestHead.from_host)
  return _s;
}
inline const std::string& RequestHead::_internal_from_host() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.from_host_.Get();
}
inline void RequestHead::_internal_set_from_host(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.from_host_.Set(value, GetArena());
}
inline std::string* RequestHead::_internal_mutable_from_host() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.from_host_.Mutable( GetArena());
}
inline std::string* RequestHead::release_from_host() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:brpc.policy.RequestHead.from_host)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.from_host_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.from_host_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RequestHead::set_allocated_from_host(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.from_host_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.from_host_.IsDefault()) {
          _impl_.from_host_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:brpc.policy.RequestHead.from_host)
}

// optional uint32 content_type = 2;
inline bool RequestHead::has_content_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void RequestHead::clear_content_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.content_type_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::uint32_t RequestHead::content_type() const {
  // @@protoc_insertion_point(field_get:brpc.policy.RequestHead.content_type)
  return _internal_content_type();
}
inline void RequestHead::set_content_type(::uint32_t value) {
  _internal_set_content_type(value);
  // @@protoc_insertion_point(field_set:brpc.policy.RequestHead.content_type)
}
inline ::uint32_t RequestHead::_internal_content_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.content_type_;
}
inline void RequestHead::_internal_set_content_type(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.content_type_ = value;
}

// optional bool connection = 3;
inline bool RequestHead::has_connection() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void RequestHead::clear_connection() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.connection_ = false;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline bool RequestHead::connection() const {
  // @@protoc_insertion_point(field_get:brpc.policy.RequestHead.connection)
  return _internal_connection();
}
inline void RequestHead::set_connection(bool value) {
  _internal_set_connection(value);
  // @@protoc_insertion_point(field_set:brpc.policy.RequestHead.connection)
}
inline bool RequestHead::_internal_connection() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.connection_;
}
inline void RequestHead::_internal_set_connection(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.connection_ = value;
}

// optional string charset = 4;
inline bool RequestHead::has_charset() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void RequestHead::clear_charset() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.charset_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& RequestHead::charset() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:brpc.policy.RequestHead.charset)
  return _internal_charset();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RequestHead::set_charset(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.charset_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:brpc.policy.RequestHead.charset)
}
inline std::string* RequestHead::mutable_charset() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_charset();
  // @@protoc_insertion_point(field_mutable:brpc.policy.RequestHead.charset)
  return _s;
}
inline const std::string& RequestHead::_internal_charset() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.charset_.Get();
}
inline void RequestHead::_internal_set_charset(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.charset_.Set(value, GetArena());
}
inline std::string* RequestHead::_internal_mutable_charset() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.charset_.Mutable( GetArena());
}
inline std::string* RequestHead::release_charset() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:brpc.policy.RequestHead.charset)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.charset_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.charset_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RequestHead::set_allocated_charset(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.charset_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.charset_.IsDefault()) {
          _impl_.charset_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:brpc.policy.RequestHead.charset)
}

// optional string accept_charset = 5;
inline bool RequestHead::has_accept_charset() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void RequestHead::clear_accept_charset() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.accept_charset_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& RequestHead::accept_charset() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:brpc.policy.RequestHead.accept_charset)
  return _internal_accept_charset();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RequestHead::set_accept_charset(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.accept_charset_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:brpc.policy.RequestHead.accept_charset)
}
inline std::string* RequestHead::mutable_accept_charset() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_accept_charset();
  // @@protoc_insertion_point(field_mutable:brpc.policy.RequestHead.accept_charset)
  return _s;
}
inline const std::string& RequestHead::_internal_accept_charset() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.accept_charset_.Get();
}
inline void RequestHead::_internal_set_accept_charset(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.accept_charset_.Set(value, GetArena());
}
inline std::string* RequestHead::_internal_mutable_accept_charset() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.accept_charset_.Mutable( GetArena());
}
inline std::string* RequestHead::release_accept_charset() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:brpc.policy.RequestHead.accept_charset)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.accept_charset_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.accept_charset_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RequestHead::set_allocated_accept_charset(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.accept_charset_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.accept_charset_.IsDefault()) {
          _impl_.accept_charset_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:brpc.policy.RequestHead.accept_charset)
}

// optional string create_time = 6;
inline bool RequestHead::has_create_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void RequestHead::clear_create_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.create_time_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& RequestHead::create_time() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:brpc.policy.RequestHead.create_time)
  return _internal_create_time();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RequestHead::set_create_time(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.create_time_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:brpc.policy.RequestHead.create_time)
}
inline std::string* RequestHead::mutable_create_time() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_create_time();
  // @@protoc_insertion_point(field_mutable:brpc.policy.RequestHead.create_time)
  return _s;
}
inline const std::string& RequestHead::_internal_create_time() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.create_time_.Get();
}
inline void RequestHead::_internal_set_create_time(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.create_time_.Set(value, GetArena());
}
inline std::string* RequestHead::_internal_mutable_create_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.create_time_.Mutable( GetArena());
}
inline std::string* RequestHead::release_create_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:brpc.policy.RequestHead.create_time)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.create_time_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.create_time_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RequestHead::set_allocated_create_time(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.create_time_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.create_time_.IsDefault()) {
          _impl_.create_time_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:brpc.policy.RequestHead.create_time)
}

// optional uint64 log_id = 7;
inline bool RequestHead::has_log_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void RequestHead::clear_log_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.log_id_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::uint64_t RequestHead::log_id() const {
  // @@protoc_insertion_point(field_get:brpc.policy.RequestHead.log_id)
  return _internal_log_id();
}
inline void RequestHead::set_log_id(::uint64_t value) {
  _internal_set_log_id(value);
  // @@protoc_insertion_point(field_set:brpc.policy.RequestHead.log_id)
}
inline ::uint64_t RequestHead::_internal_log_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.log_id_;
}
inline void RequestHead::_internal_set_log_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.log_id_ = value;
}

// optional uint32 compress_type = 8;
inline bool RequestHead::has_compress_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void RequestHead::clear_compress_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.compress_type_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::uint32_t RequestHead::compress_type() const {
  // @@protoc_insertion_point(field_get:brpc.policy.RequestHead.compress_type)
  return _internal_compress_type();
}
inline void RequestHead::set_compress_type(::uint32_t value) {
  _internal_set_compress_type(value);
  // @@protoc_insertion_point(field_set:brpc.policy.RequestHead.compress_type)
}
inline ::uint32_t RequestHead::_internal_compress_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.compress_type_;
}
inline void RequestHead::_internal_set_compress_type(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.compress_type_ = value;
}

// -------------------------------------------------------------------

// RequestBody

// optional string version = 1;
inline bool RequestBody::has_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void RequestBody::clear_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.version_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RequestBody::version() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:brpc.policy.RequestBody.version)
  return _internal_version();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RequestBody::set_version(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.version_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:brpc.policy.RequestBody.version)
}
inline std::string* RequestBody::mutable_version() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:brpc.policy.RequestBody.version)
  return _s;
}
inline const std::string& RequestBody::_internal_version() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.version_.Get();
}
inline void RequestBody::_internal_set_version(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.version_.Set(value, GetArena());
}
inline std::string* RequestBody::_internal_mutable_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.version_.Mutable( GetArena());
}
inline std::string* RequestBody::release_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:brpc.policy.RequestBody.version)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.version_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.version_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RequestBody::set_allocated_version(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.version_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.version_.IsDefault()) {
          _impl_.version_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:brpc.policy.RequestBody.version)
}

// optional string charset = 2;
inline bool RequestBody::has_charset() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void RequestBody::clear_charset() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.charset_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& RequestBody::charset() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:brpc.policy.RequestBody.charset)
  return _internal_charset();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RequestBody::set_charset(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.charset_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:brpc.policy.RequestBody.charset)
}
inline std::string* RequestBody::mutable_charset() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_charset();
  // @@protoc_insertion_point(field_mutable:brpc.policy.RequestBody.charset)
  return _s;
}
inline const std::string& RequestBody::_internal_charset() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.charset_.Get();
}
inline void RequestBody::_internal_set_charset(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.charset_.Set(value, GetArena());
}
inline std::string* RequestBody::_internal_mutable_charset() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.charset_.Mutable( GetArena());
}
inline std::string* RequestBody::release_charset() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:brpc.policy.RequestBody.charset)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.charset_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.charset_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RequestBody::set_allocated_charset(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.charset_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.charset_.IsDefault()) {
          _impl_.charset_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:brpc.policy.RequestBody.charset)
}

// required string service = 3;
inline bool RequestBody::has_service() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void RequestBody::clear_service() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.service_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& RequestBody::service() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:brpc.policy.RequestBody.service)
  return _internal_service();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RequestBody::set_service(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.service_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:brpc.policy.RequestBody.service)
}
inline std::string* RequestBody::mutable_service() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_service();
  // @@protoc_insertion_point(field_mutable:brpc.policy.RequestBody.service)
  return _s;
}
inline const std::string& RequestBody::_internal_service() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.service_.Get();
}
inline void RequestBody::_internal_set_service(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.service_.Set(value, GetArena());
}
inline std::string* RequestBody::_internal_mutable_service() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.service_.Mutable( GetArena());
}
inline std::string* RequestBody::release_service() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:brpc.policy.RequestBody.service)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.service_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.service_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RequestBody::set_allocated_service(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.service_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.service_.IsDefault()) {
          _impl_.service_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:brpc.policy.RequestBody.service)
}

// required uint32 method_id = 4;
inline bool RequestBody::has_method_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void RequestBody::clear_method_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.method_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::uint32_t RequestBody::method_id() const {
  // @@protoc_insertion_point(field_get:brpc.policy.RequestBody.method_id)
  return _internal_method_id();
}
inline void RequestBody::set_method_id(::uint32_t value) {
  _internal_set_method_id(value);
  // @@protoc_insertion_point(field_set:brpc.policy.RequestBody.method_id)
}
inline ::uint32_t RequestBody::_internal_method_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.method_id_;
}
inline void RequestBody::_internal_set_method_id(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.method_id_ = value;
}

// required uint64 id = 5;
inline bool RequestBody::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void RequestBody::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::uint64_t RequestBody::id() const {
  // @@protoc_insertion_point(field_get:brpc.policy.RequestBody.id)
  return _internal_id();
}
inline void RequestBody::set_id(::uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:brpc.policy.RequestBody.id)
}
inline ::uint64_t RequestBody::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void RequestBody::_internal_set_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.id_ = value;
}

// optional bytes serialized_request = 6;
inline bool RequestBody::has_serialized_request() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void RequestBody::clear_serialized_request() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.serialized_request_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& RequestBody::serialized_request() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:brpc.policy.RequestBody.serialized_request)
  return _internal_serialized_request();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RequestBody::set_serialized_request(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.serialized_request_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:brpc.policy.RequestBody.serialized_request)
}
inline std::string* RequestBody::mutable_serialized_request() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_serialized_request();
  // @@protoc_insertion_point(field_mutable:brpc.policy.RequestBody.serialized_request)
  return _s;
}
inline const std::string& RequestBody::_internal_serialized_request() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.serialized_request_.Get();
}
inline void RequestBody::_internal_set_serialized_request(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.serialized_request_.Set(value, GetArena());
}
inline std::string* RequestBody::_internal_mutable_serialized_request() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.serialized_request_.Mutable( GetArena());
}
inline std::string* RequestBody::release_serialized_request() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:brpc.policy.RequestBody.serialized_request)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.serialized_request_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.serialized_request_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RequestBody::set_allocated_serialized_request(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.serialized_request_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.serialized_request_.IsDefault()) {
          _impl_.serialized_request_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:brpc.policy.RequestBody.serialized_request)
}

// -------------------------------------------------------------------

// PublicPbrpcResponse

// optional .brpc.policy.ResponseHead responseHead = 1;
inline bool PublicPbrpcResponse::has_responsehead() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.responsehead_ != nullptr);
  return value;
}
inline void PublicPbrpcResponse::clear_responsehead() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.responsehead_ != nullptr) _impl_.responsehead_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::brpc::policy::ResponseHead& PublicPbrpcResponse::_internal_responsehead() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::brpc::policy::ResponseHead* p = _impl_.responsehead_;
  return p != nullptr ? *p : reinterpret_cast<const ::brpc::policy::ResponseHead&>(::brpc::policy::_ResponseHead_default_instance_);
}
inline const ::brpc::policy::ResponseHead& PublicPbrpcResponse::responsehead() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:brpc.policy.PublicPbrpcResponse.responseHead)
  return _internal_responsehead();
}
inline void PublicPbrpcResponse::unsafe_arena_set_allocated_responsehead(::brpc::policy::ResponseHead* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.responsehead_);
  }
  _impl_.responsehead_ = reinterpret_cast<::brpc::policy::ResponseHead*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:brpc.policy.PublicPbrpcResponse.responseHead)
}
inline ::brpc::policy::ResponseHead* PublicPbrpcResponse::release_responsehead() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::brpc::policy::ResponseHead* released = _impl_.responsehead_;
  _impl_.responsehead_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::brpc::policy::ResponseHead* PublicPbrpcResponse::unsafe_arena_release_responsehead() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:brpc.policy.PublicPbrpcResponse.responseHead)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::brpc::policy::ResponseHead* temp = _impl_.responsehead_;
  _impl_.responsehead_ = nullptr;
  return temp;
}
inline ::brpc::policy::ResponseHead* PublicPbrpcResponse::_internal_mutable_responsehead() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.responsehead_ == nullptr) {
    auto* p = CreateMaybeMessage<::brpc::policy::ResponseHead>(GetArena());
    _impl_.responsehead_ = reinterpret_cast<::brpc::policy::ResponseHead*>(p);
  }
  return _impl_.responsehead_;
}
inline ::brpc::policy::ResponseHead* PublicPbrpcResponse::mutable_responsehead() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::brpc::policy::ResponseHead* _msg = _internal_mutable_responsehead();
  // @@protoc_insertion_point(field_mutable:brpc.policy.PublicPbrpcResponse.responseHead)
  return _msg;
}
inline void PublicPbrpcResponse::set_allocated_responsehead(::brpc::policy::ResponseHead* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::brpc::policy::ResponseHead*>(_impl_.responsehead_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::brpc::policy::ResponseHead*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.responsehead_ = reinterpret_cast<::brpc::policy::ResponseHead*>(value);
  // @@protoc_insertion_point(field_set_allocated:brpc.policy.PublicPbrpcResponse.responseHead)
}

// repeated .brpc.policy.ResponseBody responseBody = 2;
inline int PublicPbrpcResponse::_internal_responsebody_size() const {
  return _internal_responsebody().size();
}
inline int PublicPbrpcResponse::responsebody_size() const {
  return _internal_responsebody_size();
}
inline void PublicPbrpcResponse::clear_responsebody() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.responsebody_.Clear();
}
inline ::brpc::policy::ResponseBody* PublicPbrpcResponse::mutable_responsebody(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:brpc.policy.PublicPbrpcResponse.responseBody)
  return _internal_mutable_responsebody()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::brpc::policy::ResponseBody>* PublicPbrpcResponse::mutable_responsebody()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:brpc.policy.PublicPbrpcResponse.responseBody)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_responsebody();
}
inline const ::brpc::policy::ResponseBody& PublicPbrpcResponse::responsebody(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:brpc.policy.PublicPbrpcResponse.responseBody)
  return _internal_responsebody().Get(index);
}
inline ::brpc::policy::ResponseBody* PublicPbrpcResponse::add_responsebody() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::brpc::policy::ResponseBody* _add = _internal_mutable_responsebody()->Add();
  // @@protoc_insertion_point(field_add:brpc.policy.PublicPbrpcResponse.responseBody)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::brpc::policy::ResponseBody>& PublicPbrpcResponse::responsebody() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:brpc.policy.PublicPbrpcResponse.responseBody)
  return _internal_responsebody();
}
inline const ::google::protobuf::RepeatedPtrField<::brpc::policy::ResponseBody>&
PublicPbrpcResponse::_internal_responsebody() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.responsebody_;
}
inline ::google::protobuf::RepeatedPtrField<::brpc::policy::ResponseBody>*
PublicPbrpcResponse::_internal_mutable_responsebody() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.responsebody_;
}

// -------------------------------------------------------------------

// ResponseHead

// required sint32 code = 1;
inline bool ResponseHead::has_code() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void ResponseHead::clear_code() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.code_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t ResponseHead::code() const {
  // @@protoc_insertion_point(field_get:brpc.policy.ResponseHead.code)
  return _internal_code();
}
inline void ResponseHead::set_code(::int32_t value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:brpc.policy.ResponseHead.code)
}
inline ::int32_t ResponseHead::_internal_code() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.code_;
}
inline void ResponseHead::_internal_set_code(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.code_ = value;
}

// optional string text = 2;
inline bool ResponseHead::has_text() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ResponseHead::clear_text() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.text_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ResponseHead::text() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:brpc.policy.ResponseHead.text)
  return _internal_text();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ResponseHead::set_text(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.text_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:brpc.policy.ResponseHead.text)
}
inline std::string* ResponseHead::mutable_text() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:brpc.policy.ResponseHead.text)
  return _s;
}
inline const std::string& ResponseHead::_internal_text() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.text_.Get();
}
inline void ResponseHead::_internal_set_text(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.text_.Set(value, GetArena());
}
inline std::string* ResponseHead::_internal_mutable_text() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.text_.Mutable( GetArena());
}
inline std::string* ResponseHead::release_text() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:brpc.policy.ResponseHead.text)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.text_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.text_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ResponseHead::set_allocated_text(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.text_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.text_.IsDefault()) {
          _impl_.text_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:brpc.policy.ResponseHead.text)
}

// optional string from_host = 3;
inline bool ResponseHead::has_from_host() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void ResponseHead::clear_from_host() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.from_host_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ResponseHead::from_host() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:brpc.policy.ResponseHead.from_host)
  return _internal_from_host();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ResponseHead::set_from_host(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.from_host_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:brpc.policy.ResponseHead.from_host)
}
inline std::string* ResponseHead::mutable_from_host() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_from_host();
  // @@protoc_insertion_point(field_mutable:brpc.policy.ResponseHead.from_host)
  return _s;
}
inline const std::string& ResponseHead::_internal_from_host() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.from_host_.Get();
}
inline void ResponseHead::_internal_set_from_host(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.from_host_.Set(value, GetArena());
}
inline std::string* ResponseHead::_internal_mutable_from_host() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.from_host_.Mutable( GetArena());
}
inline std::string* ResponseHead::release_from_host() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:brpc.policy.ResponseHead.from_host)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.from_host_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.from_host_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ResponseHead::set_allocated_from_host(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.from_host_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.from_host_.IsDefault()) {
          _impl_.from_host_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:brpc.policy.ResponseHead.from_host)
}

// optional uint32 compress_type = 4;
inline bool ResponseHead::has_compress_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void ResponseHead::clear_compress_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.compress_type_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint32_t ResponseHead::compress_type() const {
  // @@protoc_insertion_point(field_get:brpc.policy.ResponseHead.compress_type)
  return _internal_compress_type();
}
inline void ResponseHead::set_compress_type(::uint32_t value) {
  _internal_set_compress_type(value);
  // @@protoc_insertion_point(field_set:brpc.policy.ResponseHead.compress_type)
}
inline ::uint32_t ResponseHead::_internal_compress_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.compress_type_;
}
inline void ResponseHead::_internal_set_compress_type(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.compress_type_ = value;
}

// -------------------------------------------------------------------

// ResponseBody

// optional bytes serialized_response = 1;
inline bool ResponseBody::has_serialized_response() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ResponseBody::clear_serialized_response() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.serialized_response_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ResponseBody::serialized_response() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:brpc.policy.ResponseBody.serialized_response)
  return _internal_serialized_response();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ResponseBody::set_serialized_response(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.serialized_response_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:brpc.policy.ResponseBody.serialized_response)
}
inline std::string* ResponseBody::mutable_serialized_response() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_serialized_response();
  // @@protoc_insertion_point(field_mutable:brpc.policy.ResponseBody.serialized_response)
  return _s;
}
inline const std::string& ResponseBody::_internal_serialized_response() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.serialized_response_.Get();
}
inline void ResponseBody::_internal_set_serialized_response(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.serialized_response_.Set(value, GetArena());
}
inline std::string* ResponseBody::_internal_mutable_serialized_response() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.serialized_response_.Mutable( GetArena());
}
inline std::string* ResponseBody::release_serialized_response() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:brpc.policy.ResponseBody.serialized_response)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.serialized_response_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.serialized_response_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ResponseBody::set_allocated_serialized_response(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.serialized_response_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.serialized_response_.IsDefault()) {
          _impl_.serialized_response_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:brpc.policy.ResponseBody.serialized_response)
}

// optional string version = 2;
inline bool ResponseBody::has_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void ResponseBody::clear_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.version_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ResponseBody::version() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:brpc.policy.ResponseBody.version)
  return _internal_version();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ResponseBody::set_version(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.version_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:brpc.policy.ResponseBody.version)
}
inline std::string* ResponseBody::mutable_version() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:brpc.policy.ResponseBody.version)
  return _s;
}
inline const std::string& ResponseBody::_internal_version() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.version_.Get();
}
inline void ResponseBody::_internal_set_version(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.version_.Set(value, GetArena());
}
inline std::string* ResponseBody::_internal_mutable_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.version_.Mutable( GetArena());
}
inline std::string* ResponseBody::release_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:brpc.policy.ResponseBody.version)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.version_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.version_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ResponseBody::set_allocated_version(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.version_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.version_.IsDefault()) {
          _impl_.version_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:brpc.policy.ResponseBody.version)
}

// optional int32 error = 3;
inline bool ResponseBody::has_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void ResponseBody::clear_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.error_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int32_t ResponseBody::error() const {
  // @@protoc_insertion_point(field_get:brpc.policy.ResponseBody.error)
  return _internal_error();
}
inline void ResponseBody::set_error(::int32_t value) {
  _internal_set_error(value);
  // @@protoc_insertion_point(field_set:brpc.policy.ResponseBody.error)
}
inline ::int32_t ResponseBody::_internal_error() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.error_;
}
inline void ResponseBody::_internal_set_error(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.error_ = value;
}

// required uint64 id = 4;
inline bool ResponseBody::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void ResponseBody::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint64_t ResponseBody::id() const {
  // @@protoc_insertion_point(field_get:brpc.policy.ResponseBody.id)
  return _internal_id();
}
inline void ResponseBody::set_id(::uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:brpc.policy.ResponseBody.id)
}
inline ::uint64_t ResponseBody::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void ResponseBody::_internal_set_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.id_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace policy
}  // namespace brpc


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_brpc_2fpolicy_2fpublic_5fpbrpc_5fmeta_2eproto_2epb_2eh

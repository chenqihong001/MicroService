// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: brpc/rtmp.proto
// Protobuf C++ Version: 4.25.1

#ifndef GOOGLE_PROTOBUF_INCLUDED_brpc_2frtmp_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_brpc_2frtmp_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025001 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_brpc_2frtmp_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_brpc_2frtmp_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_brpc_2frtmp_2eproto;
namespace brpc {
class RtmpConnectRequest;
struct RtmpConnectRequestDefaultTypeInternal;
extern RtmpConnectRequestDefaultTypeInternal _RtmpConnectRequest_default_instance_;
class RtmpConnectResponse;
struct RtmpConnectResponseDefaultTypeInternal;
extern RtmpConnectResponseDefaultTypeInternal _RtmpConnectResponse_default_instance_;
class RtmpEmptyObject;
struct RtmpEmptyObjectDefaultTypeInternal;
extern RtmpEmptyObjectDefaultTypeInternal _RtmpEmptyObject_default_instance_;
class RtmpInfo;
struct RtmpInfoDefaultTypeInternal;
extern RtmpInfoDefaultTypeInternal _RtmpInfo_default_instance_;
class RtmpPlay2Options;
struct RtmpPlay2OptionsDefaultTypeInternal;
extern RtmpPlay2OptionsDefaultTypeInternal _RtmpPlay2Options_default_instance_;
}  // namespace brpc
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace brpc {

// ===================================================================


// -------------------------------------------------------------------

class RtmpPlay2Options final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:brpc.RtmpPlay2Options) */ {
 public:
  inline RtmpPlay2Options() : RtmpPlay2Options(nullptr) {}
  ~RtmpPlay2Options() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RtmpPlay2Options(::google::protobuf::internal::ConstantInitialized);

  inline RtmpPlay2Options(const RtmpPlay2Options& from)
      : RtmpPlay2Options(nullptr, from) {}
  RtmpPlay2Options(RtmpPlay2Options&& from) noexcept
    : RtmpPlay2Options() {
    *this = ::std::move(from);
  }

  inline RtmpPlay2Options& operator=(const RtmpPlay2Options& from) {
    CopyFrom(from);
    return *this;
  }
  inline RtmpPlay2Options& operator=(RtmpPlay2Options&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RtmpPlay2Options& default_instance() {
    return *internal_default_instance();
  }
  static inline const RtmpPlay2Options* internal_default_instance() {
    return reinterpret_cast<const RtmpPlay2Options*>(
               &_RtmpPlay2Options_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(RtmpPlay2Options& a, RtmpPlay2Options& b) {
    a.Swap(&b);
  }
  inline void Swap(RtmpPlay2Options* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RtmpPlay2Options* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RtmpPlay2Options* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RtmpPlay2Options>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RtmpPlay2Options& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RtmpPlay2Options& from) {
    RtmpPlay2Options::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RtmpPlay2Options* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "brpc.RtmpPlay2Options";
  }
  protected:
  explicit RtmpPlay2Options(::google::protobuf::Arena* arena);
  RtmpPlay2Options(::google::protobuf::Arena* arena, const RtmpPlay2Options& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOldStreamNameFieldNumber = 3,
    kStreamNameFieldNumber = 5,
    kTransitionFieldNumber = 6,
    kLenFieldNumber = 1,
    kOffsetFieldNumber = 2,
    kStartFieldNumber = 4,
  };
  // optional string oldStreamName = 3;
  bool has_oldstreamname() const;
  void clear_oldstreamname() ;
  const std::string& oldstreamname() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_oldstreamname(Arg_&& arg, Args_... args);
  std::string* mutable_oldstreamname();
  PROTOBUF_NODISCARD std::string* release_oldstreamname();
  void set_allocated_oldstreamname(std::string* value);

  private:
  const std::string& _internal_oldstreamname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_oldstreamname(
      const std::string& value);
  std::string* _internal_mutable_oldstreamname();

  public:
  // optional string streamName = 5;
  bool has_streamname() const;
  void clear_streamname() ;
  const std::string& streamname() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_streamname(Arg_&& arg, Args_... args);
  std::string* mutable_streamname();
  PROTOBUF_NODISCARD std::string* release_streamname();
  void set_allocated_streamname(std::string* value);

  private:
  const std::string& _internal_streamname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_streamname(
      const std::string& value);
  std::string* _internal_mutable_streamname();

  public:
  // optional string transition = 6;
  bool has_transition() const;
  void clear_transition() ;
  const std::string& transition() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_transition(Arg_&& arg, Args_... args);
  std::string* mutable_transition();
  PROTOBUF_NODISCARD std::string* release_transition();
  void set_allocated_transition(std::string* value);

  private:
  const std::string& _internal_transition() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_transition(
      const std::string& value);
  std::string* _internal_mutable_transition();

  public:
  // optional double len = 1;
  bool has_len() const;
  void clear_len() ;
  double len() const;
  void set_len(double value);

  private:
  double _internal_len() const;
  void _internal_set_len(double value);

  public:
  // optional double offset = 2;
  bool has_offset() const;
  void clear_offset() ;
  double offset() const;
  void set_offset(double value);

  private:
  double _internal_offset() const;
  void _internal_set_offset(double value);

  public:
  // optional double start = 4;
  bool has_start() const;
  void clear_start() ;
  double start() const;
  void set_start(double value);

  private:
  double _internal_start() const;
  void _internal_set_start(double value);

  public:
  // @@protoc_insertion_point(class_scope:brpc.RtmpPlay2Options)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 0,
      63, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr oldstreamname_;
    ::google::protobuf::internal::ArenaStringPtr streamname_;
    ::google::protobuf::internal::ArenaStringPtr transition_;
    double len_;
    double offset_;
    double start_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_brpc_2frtmp_2eproto;
};// -------------------------------------------------------------------

class RtmpInfo final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:brpc.RtmpInfo) */ {
 public:
  inline RtmpInfo() : RtmpInfo(nullptr) {}
  ~RtmpInfo() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RtmpInfo(::google::protobuf::internal::ConstantInitialized);

  inline RtmpInfo(const RtmpInfo& from)
      : RtmpInfo(nullptr, from) {}
  RtmpInfo(RtmpInfo&& from) noexcept
    : RtmpInfo() {
    *this = ::std::move(from);
  }

  inline RtmpInfo& operator=(const RtmpInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline RtmpInfo& operator=(RtmpInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RtmpInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const RtmpInfo* internal_default_instance() {
    return reinterpret_cast<const RtmpInfo*>(
               &_RtmpInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(RtmpInfo& a, RtmpInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(RtmpInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RtmpInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RtmpInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RtmpInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RtmpInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RtmpInfo& from) {
    RtmpInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RtmpInfo* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "brpc.RtmpInfo";
  }
  protected:
  explicit RtmpInfo(::google::protobuf::Arena* arena);
  RtmpInfo(::google::protobuf::Arena* arena, const RtmpInfo& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCodeFieldNumber = 1,
    kLevelFieldNumber = 2,
    kDescriptionFieldNumber = 3,
    kObjectEncodingFieldNumber = 4,
  };
  // optional string code = 1;
  bool has_code() const;
  void clear_code() ;
  const std::string& code() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_code(Arg_&& arg, Args_... args);
  std::string* mutable_code();
  PROTOBUF_NODISCARD std::string* release_code();
  void set_allocated_code(std::string* value);

  private:
  const std::string& _internal_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_code(
      const std::string& value);
  std::string* _internal_mutable_code();

  public:
  // optional string level = 2;
  bool has_level() const;
  void clear_level() ;
  const std::string& level() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_level(Arg_&& arg, Args_... args);
  std::string* mutable_level();
  PROTOBUF_NODISCARD std::string* release_level();
  void set_allocated_level(std::string* value);

  private:
  const std::string& _internal_level() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_level(
      const std::string& value);
  std::string* _internal_mutable_level();

  public:
  // optional string description = 3;
  bool has_description() const;
  void clear_description() ;
  const std::string& description() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_description(Arg_&& arg, Args_... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* value);

  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(
      const std::string& value);
  std::string* _internal_mutable_description();

  public:
  // optional double objectEncoding = 4;
  bool has_objectencoding() const;
  void clear_objectencoding() ;
  double objectencoding() const;
  void set_objectencoding(double value);

  private:
  double _internal_objectencoding() const;
  void _internal_set_objectencoding(double value);

  public:
  // @@protoc_insertion_point(class_scope:brpc.RtmpInfo)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      42, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr code_;
    ::google::protobuf::internal::ArenaStringPtr level_;
    ::google::protobuf::internal::ArenaStringPtr description_;
    double objectencoding_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_brpc_2frtmp_2eproto;
};// -------------------------------------------------------------------

class RtmpEmptyObject final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:brpc.RtmpEmptyObject) */ {
 public:
  inline RtmpEmptyObject() : RtmpEmptyObject(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RtmpEmptyObject(::google::protobuf::internal::ConstantInitialized);

  inline RtmpEmptyObject(const RtmpEmptyObject& from)
      : RtmpEmptyObject(nullptr, from) {}
  RtmpEmptyObject(RtmpEmptyObject&& from) noexcept
    : RtmpEmptyObject() {
    *this = ::std::move(from);
  }

  inline RtmpEmptyObject& operator=(const RtmpEmptyObject& from) {
    CopyFrom(from);
    return *this;
  }
  inline RtmpEmptyObject& operator=(RtmpEmptyObject&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RtmpEmptyObject& default_instance() {
    return *internal_default_instance();
  }
  static inline const RtmpEmptyObject* internal_default_instance() {
    return reinterpret_cast<const RtmpEmptyObject*>(
               &_RtmpEmptyObject_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(RtmpEmptyObject& a, RtmpEmptyObject& b) {
    a.Swap(&b);
  }
  inline void Swap(RtmpEmptyObject* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RtmpEmptyObject* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RtmpEmptyObject* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RtmpEmptyObject>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const RtmpEmptyObject& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const RtmpEmptyObject& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "brpc.RtmpEmptyObject";
  }
  protected:
  explicit RtmpEmptyObject(::google::protobuf::Arena* arena);
  RtmpEmptyObject(::google::protobuf::Arena* arena, const RtmpEmptyObject& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:brpc.RtmpEmptyObject)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_brpc_2frtmp_2eproto;
};// -------------------------------------------------------------------

class RtmpConnectResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:brpc.RtmpConnectResponse) */ {
 public:
  inline RtmpConnectResponse() : RtmpConnectResponse(nullptr) {}
  ~RtmpConnectResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RtmpConnectResponse(::google::protobuf::internal::ConstantInitialized);

  inline RtmpConnectResponse(const RtmpConnectResponse& from)
      : RtmpConnectResponse(nullptr, from) {}
  RtmpConnectResponse(RtmpConnectResponse&& from) noexcept
    : RtmpConnectResponse() {
    *this = ::std::move(from);
  }

  inline RtmpConnectResponse& operator=(const RtmpConnectResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RtmpConnectResponse& operator=(RtmpConnectResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RtmpConnectResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RtmpConnectResponse* internal_default_instance() {
    return reinterpret_cast<const RtmpConnectResponse*>(
               &_RtmpConnectResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(RtmpConnectResponse& a, RtmpConnectResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RtmpConnectResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RtmpConnectResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RtmpConnectResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RtmpConnectResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RtmpConnectResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RtmpConnectResponse& from) {
    RtmpConnectResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RtmpConnectResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "brpc.RtmpConnectResponse";
  }
  protected:
  explicit RtmpConnectResponse(::google::protobuf::Arena* arena);
  RtmpConnectResponse(::google::protobuf::Arena* arena, const RtmpConnectResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFmsVerFieldNumber = 1,
    kCapabilitiesFieldNumber = 2,
    kModeFieldNumber = 3,
    kCreateStreamWithPlayOrPublishFieldNumber = 4,
  };
  // optional string fmsVer = 1;
  bool has_fmsver() const;
  void clear_fmsver() ;
  const std::string& fmsver() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_fmsver(Arg_&& arg, Args_... args);
  std::string* mutable_fmsver();
  PROTOBUF_NODISCARD std::string* release_fmsver();
  void set_allocated_fmsver(std::string* value);

  private:
  const std::string& _internal_fmsver() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fmsver(
      const std::string& value);
  std::string* _internal_mutable_fmsver();

  public:
  // optional double capabilities = 2;
  bool has_capabilities() const;
  void clear_capabilities() ;
  double capabilities() const;
  void set_capabilities(double value);

  private:
  double _internal_capabilities() const;
  void _internal_set_capabilities(double value);

  public:
  // optional double mode = 3;
  bool has_mode() const;
  void clear_mode() ;
  double mode() const;
  void set_mode(double value);

  private:
  double _internal_mode() const;
  void _internal_set_mode(double value);

  public:
  // optional bool create_stream_with_play_or_publish = 4;
  bool has_create_stream_with_play_or_publish() const;
  void clear_create_stream_with_play_or_publish() ;
  bool create_stream_with_play_or_publish() const;
  void set_create_stream_with_play_or_publish(bool value);

  private:
  bool _internal_create_stream_with_play_or_publish() const;
  void _internal_set_create_stream_with_play_or_publish(bool value);

  public:
  // @@protoc_insertion_point(class_scope:brpc.RtmpConnectResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      39, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr fmsver_;
    double capabilities_;
    double mode_;
    bool create_stream_with_play_or_publish_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_brpc_2frtmp_2eproto;
};// -------------------------------------------------------------------

class RtmpConnectRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:brpc.RtmpConnectRequest) */ {
 public:
  inline RtmpConnectRequest() : RtmpConnectRequest(nullptr) {}
  ~RtmpConnectRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RtmpConnectRequest(::google::protobuf::internal::ConstantInitialized);

  inline RtmpConnectRequest(const RtmpConnectRequest& from)
      : RtmpConnectRequest(nullptr, from) {}
  RtmpConnectRequest(RtmpConnectRequest&& from) noexcept
    : RtmpConnectRequest() {
    *this = ::std::move(from);
  }

  inline RtmpConnectRequest& operator=(const RtmpConnectRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RtmpConnectRequest& operator=(RtmpConnectRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RtmpConnectRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RtmpConnectRequest* internal_default_instance() {
    return reinterpret_cast<const RtmpConnectRequest*>(
               &_RtmpConnectRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(RtmpConnectRequest& a, RtmpConnectRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RtmpConnectRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RtmpConnectRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RtmpConnectRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RtmpConnectRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RtmpConnectRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RtmpConnectRequest& from) {
    RtmpConnectRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RtmpConnectRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "brpc.RtmpConnectRequest";
  }
  protected:
  explicit RtmpConnectRequest(::google::protobuf::Arena* arena);
  RtmpConnectRequest(::google::protobuf::Arena* arena, const RtmpConnectRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAppFieldNumber = 1,
    kFlashVerFieldNumber = 2,
    kSwfUrlFieldNumber = 3,
    kTcUrlFieldNumber = 4,
    kPageUrlFieldNumber = 10,
    kCapabilitiesFieldNumber = 6,
    kAudioCodecsFieldNumber = 7,
    kVideoCodecsFieldNumber = 8,
    kVideoFunctionFieldNumber = 9,
    kObjectEncodingFieldNumber = 11,
    kFpadFieldNumber = 5,
    kStreamMultiplexingFieldNumber = 12,
  };
  // optional string app = 1;
  bool has_app() const;
  void clear_app() ;
  const std::string& app() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_app(Arg_&& arg, Args_... args);
  std::string* mutable_app();
  PROTOBUF_NODISCARD std::string* release_app();
  void set_allocated_app(std::string* value);

  private:
  const std::string& _internal_app() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_app(
      const std::string& value);
  std::string* _internal_mutable_app();

  public:
  // optional string flashVer = 2;
  bool has_flashver() const;
  void clear_flashver() ;
  const std::string& flashver() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_flashver(Arg_&& arg, Args_... args);
  std::string* mutable_flashver();
  PROTOBUF_NODISCARD std::string* release_flashver();
  void set_allocated_flashver(std::string* value);

  private:
  const std::string& _internal_flashver() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_flashver(
      const std::string& value);
  std::string* _internal_mutable_flashver();

  public:
  // optional string swfUrl = 3;
  bool has_swfurl() const;
  void clear_swfurl() ;
  const std::string& swfurl() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_swfurl(Arg_&& arg, Args_... args);
  std::string* mutable_swfurl();
  PROTOBUF_NODISCARD std::string* release_swfurl();
  void set_allocated_swfurl(std::string* value);

  private:
  const std::string& _internal_swfurl() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_swfurl(
      const std::string& value);
  std::string* _internal_mutable_swfurl();

  public:
  // optional string tcUrl = 4;
  bool has_tcurl() const;
  void clear_tcurl() ;
  const std::string& tcurl() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_tcurl(Arg_&& arg, Args_... args);
  std::string* mutable_tcurl();
  PROTOBUF_NODISCARD std::string* release_tcurl();
  void set_allocated_tcurl(std::string* value);

  private:
  const std::string& _internal_tcurl() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tcurl(
      const std::string& value);
  std::string* _internal_mutable_tcurl();

  public:
  // optional string pageUrl = 10;
  bool has_pageurl() const;
  void clear_pageurl() ;
  const std::string& pageurl() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_pageurl(Arg_&& arg, Args_... args);
  std::string* mutable_pageurl();
  PROTOBUF_NODISCARD std::string* release_pageurl();
  void set_allocated_pageurl(std::string* value);

  private:
  const std::string& _internal_pageurl() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pageurl(
      const std::string& value);
  std::string* _internal_mutable_pageurl();

  public:
  // optional double capabilities = 6;
  bool has_capabilities() const;
  void clear_capabilities() ;
  double capabilities() const;
  void set_capabilities(double value);

  private:
  double _internal_capabilities() const;
  void _internal_set_capabilities(double value);

  public:
  // optional double audioCodecs = 7;
  bool has_audiocodecs() const;
  void clear_audiocodecs() ;
  double audiocodecs() const;
  void set_audiocodecs(double value);

  private:
  double _internal_audiocodecs() const;
  void _internal_set_audiocodecs(double value);

  public:
  // optional double videoCodecs = 8;
  bool has_videocodecs() const;
  void clear_videocodecs() ;
  double videocodecs() const;
  void set_videocodecs(double value);

  private:
  double _internal_videocodecs() const;
  void _internal_set_videocodecs(double value);

  public:
  // optional double videoFunction = 9;
  bool has_videofunction() const;
  void clear_videofunction() ;
  double videofunction() const;
  void set_videofunction(double value);

  private:
  double _internal_videofunction() const;
  void _internal_set_videofunction(double value);

  public:
  // optional double objectEncoding = 11;
  bool has_objectencoding() const;
  void clear_objectencoding() ;
  double objectencoding() const;
  void set_objectencoding(double value);

  private:
  double _internal_objectencoding() const;
  void _internal_set_objectencoding(double value);

  public:
  // optional bool fpad = 5;
  bool has_fpad() const;
  void clear_fpad() ;
  bool fpad() const;
  void set_fpad(bool value);

  private:
  bool _internal_fpad() const;
  void _internal_set_fpad(bool value);

  public:
  // optional bool stream_multiplexing = 12;
  bool has_stream_multiplexing() const;
  void clear_stream_multiplexing() ;
  bool stream_multiplexing() const;
  void set_stream_multiplexing(bool value);

  private:
  bool _internal_stream_multiplexing() const;
  void _internal_set_stream_multiplexing(bool value);

  public:
  // @@protoc_insertion_point(class_scope:brpc.RtmpConnectRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 12, 0,
      69, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr app_;
    ::google::protobuf::internal::ArenaStringPtr flashver_;
    ::google::protobuf::internal::ArenaStringPtr swfurl_;
    ::google::protobuf::internal::ArenaStringPtr tcurl_;
    ::google::protobuf::internal::ArenaStringPtr pageurl_;
    double capabilities_;
    double audiocodecs_;
    double videocodecs_;
    double videofunction_;
    double objectencoding_;
    bool fpad_;
    bool stream_multiplexing_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_brpc_2frtmp_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// RtmpConnectRequest

// optional string app = 1;
inline bool RtmpConnectRequest::has_app() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void RtmpConnectRequest::clear_app() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.app_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RtmpConnectRequest::app() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:brpc.RtmpConnectRequest.app)
  return _internal_app();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RtmpConnectRequest::set_app(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.app_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:brpc.RtmpConnectRequest.app)
}
inline std::string* RtmpConnectRequest::mutable_app() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_app();
  // @@protoc_insertion_point(field_mutable:brpc.RtmpConnectRequest.app)
  return _s;
}
inline const std::string& RtmpConnectRequest::_internal_app() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.app_.Get();
}
inline void RtmpConnectRequest::_internal_set_app(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.app_.Set(value, GetArena());
}
inline std::string* RtmpConnectRequest::_internal_mutable_app() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.app_.Mutable( GetArena());
}
inline std::string* RtmpConnectRequest::release_app() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:brpc.RtmpConnectRequest.app)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.app_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.app_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RtmpConnectRequest::set_allocated_app(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.app_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.app_.IsDefault()) {
          _impl_.app_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:brpc.RtmpConnectRequest.app)
}

// optional string flashVer = 2;
inline bool RtmpConnectRequest::has_flashver() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void RtmpConnectRequest::clear_flashver() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.flashver_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& RtmpConnectRequest::flashver() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:brpc.RtmpConnectRequest.flashVer)
  return _internal_flashver();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RtmpConnectRequest::set_flashver(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.flashver_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:brpc.RtmpConnectRequest.flashVer)
}
inline std::string* RtmpConnectRequest::mutable_flashver() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_flashver();
  // @@protoc_insertion_point(field_mutable:brpc.RtmpConnectRequest.flashVer)
  return _s;
}
inline const std::string& RtmpConnectRequest::_internal_flashver() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.flashver_.Get();
}
inline void RtmpConnectRequest::_internal_set_flashver(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.flashver_.Set(value, GetArena());
}
inline std::string* RtmpConnectRequest::_internal_mutable_flashver() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.flashver_.Mutable( GetArena());
}
inline std::string* RtmpConnectRequest::release_flashver() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:brpc.RtmpConnectRequest.flashVer)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.flashver_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.flashver_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RtmpConnectRequest::set_allocated_flashver(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.flashver_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.flashver_.IsDefault()) {
          _impl_.flashver_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:brpc.RtmpConnectRequest.flashVer)
}

// optional string swfUrl = 3;
inline bool RtmpConnectRequest::has_swfurl() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void RtmpConnectRequest::clear_swfurl() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.swfurl_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& RtmpConnectRequest::swfurl() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:brpc.RtmpConnectRequest.swfUrl)
  return _internal_swfurl();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RtmpConnectRequest::set_swfurl(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.swfurl_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:brpc.RtmpConnectRequest.swfUrl)
}
inline std::string* RtmpConnectRequest::mutable_swfurl() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_swfurl();
  // @@protoc_insertion_point(field_mutable:brpc.RtmpConnectRequest.swfUrl)
  return _s;
}
inline const std::string& RtmpConnectRequest::_internal_swfurl() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.swfurl_.Get();
}
inline void RtmpConnectRequest::_internal_set_swfurl(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.swfurl_.Set(value, GetArena());
}
inline std::string* RtmpConnectRequest::_internal_mutable_swfurl() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.swfurl_.Mutable( GetArena());
}
inline std::string* RtmpConnectRequest::release_swfurl() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:brpc.RtmpConnectRequest.swfUrl)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.swfurl_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.swfurl_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RtmpConnectRequest::set_allocated_swfurl(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.swfurl_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.swfurl_.IsDefault()) {
          _impl_.swfurl_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:brpc.RtmpConnectRequest.swfUrl)
}

// optional string tcUrl = 4;
inline bool RtmpConnectRequest::has_tcurl() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void RtmpConnectRequest::clear_tcurl() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.tcurl_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& RtmpConnectRequest::tcurl() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:brpc.RtmpConnectRequest.tcUrl)
  return _internal_tcurl();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RtmpConnectRequest::set_tcurl(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.tcurl_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:brpc.RtmpConnectRequest.tcUrl)
}
inline std::string* RtmpConnectRequest::mutable_tcurl() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_tcurl();
  // @@protoc_insertion_point(field_mutable:brpc.RtmpConnectRequest.tcUrl)
  return _s;
}
inline const std::string& RtmpConnectRequest::_internal_tcurl() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tcurl_.Get();
}
inline void RtmpConnectRequest::_internal_set_tcurl(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.tcurl_.Set(value, GetArena());
}
inline std::string* RtmpConnectRequest::_internal_mutable_tcurl() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.tcurl_.Mutable( GetArena());
}
inline std::string* RtmpConnectRequest::release_tcurl() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:brpc.RtmpConnectRequest.tcUrl)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.tcurl_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.tcurl_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RtmpConnectRequest::set_allocated_tcurl(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.tcurl_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.tcurl_.IsDefault()) {
          _impl_.tcurl_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:brpc.RtmpConnectRequest.tcUrl)
}

// optional bool fpad = 5;
inline bool RtmpConnectRequest::has_fpad() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline void RtmpConnectRequest::clear_fpad() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.fpad_ = false;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline bool RtmpConnectRequest::fpad() const {
  // @@protoc_insertion_point(field_get:brpc.RtmpConnectRequest.fpad)
  return _internal_fpad();
}
inline void RtmpConnectRequest::set_fpad(bool value) {
  _internal_set_fpad(value);
  // @@protoc_insertion_point(field_set:brpc.RtmpConnectRequest.fpad)
}
inline bool RtmpConnectRequest::_internal_fpad() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.fpad_;
}
inline void RtmpConnectRequest::_internal_set_fpad(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.fpad_ = value;
}

// optional double capabilities = 6;
inline bool RtmpConnectRequest::has_capabilities() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void RtmpConnectRequest::clear_capabilities() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.capabilities_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline double RtmpConnectRequest::capabilities() const {
  // @@protoc_insertion_point(field_get:brpc.RtmpConnectRequest.capabilities)
  return _internal_capabilities();
}
inline void RtmpConnectRequest::set_capabilities(double value) {
  _internal_set_capabilities(value);
  // @@protoc_insertion_point(field_set:brpc.RtmpConnectRequest.capabilities)
}
inline double RtmpConnectRequest::_internal_capabilities() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.capabilities_;
}
inline void RtmpConnectRequest::_internal_set_capabilities(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.capabilities_ = value;
}

// optional double audioCodecs = 7;
inline bool RtmpConnectRequest::has_audiocodecs() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void RtmpConnectRequest::clear_audiocodecs() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.audiocodecs_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline double RtmpConnectRequest::audiocodecs() const {
  // @@protoc_insertion_point(field_get:brpc.RtmpConnectRequest.audioCodecs)
  return _internal_audiocodecs();
}
inline void RtmpConnectRequest::set_audiocodecs(double value) {
  _internal_set_audiocodecs(value);
  // @@protoc_insertion_point(field_set:brpc.RtmpConnectRequest.audioCodecs)
}
inline double RtmpConnectRequest::_internal_audiocodecs() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.audiocodecs_;
}
inline void RtmpConnectRequest::_internal_set_audiocodecs(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.audiocodecs_ = value;
}

// optional double videoCodecs = 8;
inline bool RtmpConnectRequest::has_videocodecs() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void RtmpConnectRequest::clear_videocodecs() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.videocodecs_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline double RtmpConnectRequest::videocodecs() const {
  // @@protoc_insertion_point(field_get:brpc.RtmpConnectRequest.videoCodecs)
  return _internal_videocodecs();
}
inline void RtmpConnectRequest::set_videocodecs(double value) {
  _internal_set_videocodecs(value);
  // @@protoc_insertion_point(field_set:brpc.RtmpConnectRequest.videoCodecs)
}
inline double RtmpConnectRequest::_internal_videocodecs() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.videocodecs_;
}
inline void RtmpConnectRequest::_internal_set_videocodecs(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.videocodecs_ = value;
}

// optional double videoFunction = 9;
inline bool RtmpConnectRequest::has_videofunction() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void RtmpConnectRequest::clear_videofunction() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.videofunction_ = 0;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline double RtmpConnectRequest::videofunction() const {
  // @@protoc_insertion_point(field_get:brpc.RtmpConnectRequest.videoFunction)
  return _internal_videofunction();
}
inline void RtmpConnectRequest::set_videofunction(double value) {
  _internal_set_videofunction(value);
  // @@protoc_insertion_point(field_set:brpc.RtmpConnectRequest.videoFunction)
}
inline double RtmpConnectRequest::_internal_videofunction() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.videofunction_;
}
inline void RtmpConnectRequest::_internal_set_videofunction(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.videofunction_ = value;
}

// optional string pageUrl = 10;
inline bool RtmpConnectRequest::has_pageurl() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void RtmpConnectRequest::clear_pageurl() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.pageurl_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& RtmpConnectRequest::pageurl() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:brpc.RtmpConnectRequest.pageUrl)
  return _internal_pageurl();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RtmpConnectRequest::set_pageurl(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.pageurl_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:brpc.RtmpConnectRequest.pageUrl)
}
inline std::string* RtmpConnectRequest::mutable_pageurl() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_pageurl();
  // @@protoc_insertion_point(field_mutable:brpc.RtmpConnectRequest.pageUrl)
  return _s;
}
inline const std::string& RtmpConnectRequest::_internal_pageurl() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.pageurl_.Get();
}
inline void RtmpConnectRequest::_internal_set_pageurl(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.pageurl_.Set(value, GetArena());
}
inline std::string* RtmpConnectRequest::_internal_mutable_pageurl() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.pageurl_.Mutable( GetArena());
}
inline std::string* RtmpConnectRequest::release_pageurl() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:brpc.RtmpConnectRequest.pageUrl)
  if ((_impl_._has_bits_[0] & 0x00000010u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* released = _impl_.pageurl_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.pageurl_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RtmpConnectRequest::set_allocated_pageurl(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.pageurl_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.pageurl_.IsDefault()) {
          _impl_.pageurl_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:brpc.RtmpConnectRequest.pageUrl)
}

// optional double objectEncoding = 11;
inline bool RtmpConnectRequest::has_objectencoding() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline void RtmpConnectRequest::clear_objectencoding() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.objectencoding_ = 0;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline double RtmpConnectRequest::objectencoding() const {
  // @@protoc_insertion_point(field_get:brpc.RtmpConnectRequest.objectEncoding)
  return _internal_objectencoding();
}
inline void RtmpConnectRequest::set_objectencoding(double value) {
  _internal_set_objectencoding(value);
  // @@protoc_insertion_point(field_set:brpc.RtmpConnectRequest.objectEncoding)
}
inline double RtmpConnectRequest::_internal_objectencoding() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.objectencoding_;
}
inline void RtmpConnectRequest::_internal_set_objectencoding(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.objectencoding_ = value;
}

// optional bool stream_multiplexing = 12;
inline bool RtmpConnectRequest::has_stream_multiplexing() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline void RtmpConnectRequest::clear_stream_multiplexing() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.stream_multiplexing_ = false;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline bool RtmpConnectRequest::stream_multiplexing() const {
  // @@protoc_insertion_point(field_get:brpc.RtmpConnectRequest.stream_multiplexing)
  return _internal_stream_multiplexing();
}
inline void RtmpConnectRequest::set_stream_multiplexing(bool value) {
  _internal_set_stream_multiplexing(value);
  // @@protoc_insertion_point(field_set:brpc.RtmpConnectRequest.stream_multiplexing)
}
inline bool RtmpConnectRequest::_internal_stream_multiplexing() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.stream_multiplexing_;
}
inline void RtmpConnectRequest::_internal_set_stream_multiplexing(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.stream_multiplexing_ = value;
}

// -------------------------------------------------------------------

// RtmpConnectResponse

// optional string fmsVer = 1;
inline bool RtmpConnectResponse::has_fmsver() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void RtmpConnectResponse::clear_fmsver() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.fmsver_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RtmpConnectResponse::fmsver() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:brpc.RtmpConnectResponse.fmsVer)
  return _internal_fmsver();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RtmpConnectResponse::set_fmsver(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.fmsver_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:brpc.RtmpConnectResponse.fmsVer)
}
inline std::string* RtmpConnectResponse::mutable_fmsver() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_fmsver();
  // @@protoc_insertion_point(field_mutable:brpc.RtmpConnectResponse.fmsVer)
  return _s;
}
inline const std::string& RtmpConnectResponse::_internal_fmsver() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.fmsver_.Get();
}
inline void RtmpConnectResponse::_internal_set_fmsver(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.fmsver_.Set(value, GetArena());
}
inline std::string* RtmpConnectResponse::_internal_mutable_fmsver() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.fmsver_.Mutable( GetArena());
}
inline std::string* RtmpConnectResponse::release_fmsver() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:brpc.RtmpConnectResponse.fmsVer)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.fmsver_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.fmsver_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RtmpConnectResponse::set_allocated_fmsver(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.fmsver_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.fmsver_.IsDefault()) {
          _impl_.fmsver_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:brpc.RtmpConnectResponse.fmsVer)
}

// optional double capabilities = 2;
inline bool RtmpConnectResponse::has_capabilities() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void RtmpConnectResponse::clear_capabilities() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.capabilities_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double RtmpConnectResponse::capabilities() const {
  // @@protoc_insertion_point(field_get:brpc.RtmpConnectResponse.capabilities)
  return _internal_capabilities();
}
inline void RtmpConnectResponse::set_capabilities(double value) {
  _internal_set_capabilities(value);
  // @@protoc_insertion_point(field_set:brpc.RtmpConnectResponse.capabilities)
}
inline double RtmpConnectResponse::_internal_capabilities() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.capabilities_;
}
inline void RtmpConnectResponse::_internal_set_capabilities(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.capabilities_ = value;
}

// optional double mode = 3;
inline bool RtmpConnectResponse::has_mode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void RtmpConnectResponse::clear_mode() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mode_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double RtmpConnectResponse::mode() const {
  // @@protoc_insertion_point(field_get:brpc.RtmpConnectResponse.mode)
  return _internal_mode();
}
inline void RtmpConnectResponse::set_mode(double value) {
  _internal_set_mode(value);
  // @@protoc_insertion_point(field_set:brpc.RtmpConnectResponse.mode)
}
inline double RtmpConnectResponse::_internal_mode() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.mode_;
}
inline void RtmpConnectResponse::_internal_set_mode(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.mode_ = value;
}

// optional bool create_stream_with_play_or_publish = 4;
inline bool RtmpConnectResponse::has_create_stream_with_play_or_publish() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void RtmpConnectResponse::clear_create_stream_with_play_or_publish() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.create_stream_with_play_or_publish_ = false;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool RtmpConnectResponse::create_stream_with_play_or_publish() const {
  // @@protoc_insertion_point(field_get:brpc.RtmpConnectResponse.create_stream_with_play_or_publish)
  return _internal_create_stream_with_play_or_publish();
}
inline void RtmpConnectResponse::set_create_stream_with_play_or_publish(bool value) {
  _internal_set_create_stream_with_play_or_publish(value);
  // @@protoc_insertion_point(field_set:brpc.RtmpConnectResponse.create_stream_with_play_or_publish)
}
inline bool RtmpConnectResponse::_internal_create_stream_with_play_or_publish() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.create_stream_with_play_or_publish_;
}
inline void RtmpConnectResponse::_internal_set_create_stream_with_play_or_publish(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.create_stream_with_play_or_publish_ = value;
}

// -------------------------------------------------------------------

// RtmpPlay2Options

// optional double len = 1;
inline bool RtmpPlay2Options::has_len() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void RtmpPlay2Options::clear_len() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.len_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline double RtmpPlay2Options::len() const {
  // @@protoc_insertion_point(field_get:brpc.RtmpPlay2Options.len)
  return _internal_len();
}
inline void RtmpPlay2Options::set_len(double value) {
  _internal_set_len(value);
  // @@protoc_insertion_point(field_set:brpc.RtmpPlay2Options.len)
}
inline double RtmpPlay2Options::_internal_len() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.len_;
}
inline void RtmpPlay2Options::_internal_set_len(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.len_ = value;
}

// optional double offset = 2;
inline bool RtmpPlay2Options::has_offset() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void RtmpPlay2Options::clear_offset() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.offset_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline double RtmpPlay2Options::offset() const {
  // @@protoc_insertion_point(field_get:brpc.RtmpPlay2Options.offset)
  return _internal_offset();
}
inline void RtmpPlay2Options::set_offset(double value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:brpc.RtmpPlay2Options.offset)
}
inline double RtmpPlay2Options::_internal_offset() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.offset_;
}
inline void RtmpPlay2Options::_internal_set_offset(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.offset_ = value;
}

// optional string oldStreamName = 3;
inline bool RtmpPlay2Options::has_oldstreamname() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void RtmpPlay2Options::clear_oldstreamname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.oldstreamname_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RtmpPlay2Options::oldstreamname() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:brpc.RtmpPlay2Options.oldStreamName)
  return _internal_oldstreamname();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RtmpPlay2Options::set_oldstreamname(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.oldstreamname_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:brpc.RtmpPlay2Options.oldStreamName)
}
inline std::string* RtmpPlay2Options::mutable_oldstreamname() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_oldstreamname();
  // @@protoc_insertion_point(field_mutable:brpc.RtmpPlay2Options.oldStreamName)
  return _s;
}
inline const std::string& RtmpPlay2Options::_internal_oldstreamname() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.oldstreamname_.Get();
}
inline void RtmpPlay2Options::_internal_set_oldstreamname(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.oldstreamname_.Set(value, GetArena());
}
inline std::string* RtmpPlay2Options::_internal_mutable_oldstreamname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.oldstreamname_.Mutable( GetArena());
}
inline std::string* RtmpPlay2Options::release_oldstreamname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:brpc.RtmpPlay2Options.oldStreamName)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.oldstreamname_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.oldstreamname_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RtmpPlay2Options::set_allocated_oldstreamname(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.oldstreamname_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.oldstreamname_.IsDefault()) {
          _impl_.oldstreamname_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:brpc.RtmpPlay2Options.oldStreamName)
}

// optional double start = 4;
inline bool RtmpPlay2Options::has_start() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void RtmpPlay2Options::clear_start() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.start_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline double RtmpPlay2Options::start() const {
  // @@protoc_insertion_point(field_get:brpc.RtmpPlay2Options.start)
  return _internal_start();
}
inline void RtmpPlay2Options::set_start(double value) {
  _internal_set_start(value);
  // @@protoc_insertion_point(field_set:brpc.RtmpPlay2Options.start)
}
inline double RtmpPlay2Options::_internal_start() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.start_;
}
inline void RtmpPlay2Options::_internal_set_start(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.start_ = value;
}

// optional string streamName = 5;
inline bool RtmpPlay2Options::has_streamname() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void RtmpPlay2Options::clear_streamname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.streamname_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& RtmpPlay2Options::streamname() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:brpc.RtmpPlay2Options.streamName)
  return _internal_streamname();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RtmpPlay2Options::set_streamname(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.streamname_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:brpc.RtmpPlay2Options.streamName)
}
inline std::string* RtmpPlay2Options::mutable_streamname() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_streamname();
  // @@protoc_insertion_point(field_mutable:brpc.RtmpPlay2Options.streamName)
  return _s;
}
inline const std::string& RtmpPlay2Options::_internal_streamname() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.streamname_.Get();
}
inline void RtmpPlay2Options::_internal_set_streamname(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.streamname_.Set(value, GetArena());
}
inline std::string* RtmpPlay2Options::_internal_mutable_streamname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.streamname_.Mutable( GetArena());
}
inline std::string* RtmpPlay2Options::release_streamname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:brpc.RtmpPlay2Options.streamName)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.streamname_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.streamname_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RtmpPlay2Options::set_allocated_streamname(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.streamname_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.streamname_.IsDefault()) {
          _impl_.streamname_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:brpc.RtmpPlay2Options.streamName)
}

// optional string transition = 6;
inline bool RtmpPlay2Options::has_transition() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void RtmpPlay2Options::clear_transition() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.transition_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& RtmpPlay2Options::transition() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:brpc.RtmpPlay2Options.transition)
  return _internal_transition();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RtmpPlay2Options::set_transition(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.transition_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:brpc.RtmpPlay2Options.transition)
}
inline std::string* RtmpPlay2Options::mutable_transition() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_transition();
  // @@protoc_insertion_point(field_mutable:brpc.RtmpPlay2Options.transition)
  return _s;
}
inline const std::string& RtmpPlay2Options::_internal_transition() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.transition_.Get();
}
inline void RtmpPlay2Options::_internal_set_transition(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.transition_.Set(value, GetArena());
}
inline std::string* RtmpPlay2Options::_internal_mutable_transition() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.transition_.Mutable( GetArena());
}
inline std::string* RtmpPlay2Options::release_transition() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:brpc.RtmpPlay2Options.transition)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.transition_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.transition_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RtmpPlay2Options::set_allocated_transition(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.transition_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.transition_.IsDefault()) {
          _impl_.transition_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:brpc.RtmpPlay2Options.transition)
}

// -------------------------------------------------------------------

// RtmpInfo

// optional string code = 1;
inline bool RtmpInfo::has_code() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void RtmpInfo::clear_code() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.code_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RtmpInfo::code() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:brpc.RtmpInfo.code)
  return _internal_code();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RtmpInfo::set_code(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.code_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:brpc.RtmpInfo.code)
}
inline std::string* RtmpInfo::mutable_code() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_code();
  // @@protoc_insertion_point(field_mutable:brpc.RtmpInfo.code)
  return _s;
}
inline const std::string& RtmpInfo::_internal_code() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.code_.Get();
}
inline void RtmpInfo::_internal_set_code(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.code_.Set(value, GetArena());
}
inline std::string* RtmpInfo::_internal_mutable_code() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.code_.Mutable( GetArena());
}
inline std::string* RtmpInfo::release_code() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:brpc.RtmpInfo.code)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.code_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.code_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RtmpInfo::set_allocated_code(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.code_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.code_.IsDefault()) {
          _impl_.code_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:brpc.RtmpInfo.code)
}

// optional string level = 2;
inline bool RtmpInfo::has_level() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void RtmpInfo::clear_level() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.level_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& RtmpInfo::level() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:brpc.RtmpInfo.level)
  return _internal_level();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RtmpInfo::set_level(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.level_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:brpc.RtmpInfo.level)
}
inline std::string* RtmpInfo::mutable_level() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_level();
  // @@protoc_insertion_point(field_mutable:brpc.RtmpInfo.level)
  return _s;
}
inline const std::string& RtmpInfo::_internal_level() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.level_.Get();
}
inline void RtmpInfo::_internal_set_level(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.level_.Set(value, GetArena());
}
inline std::string* RtmpInfo::_internal_mutable_level() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.level_.Mutable( GetArena());
}
inline std::string* RtmpInfo::release_level() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:brpc.RtmpInfo.level)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.level_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.level_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RtmpInfo::set_allocated_level(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.level_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.level_.IsDefault()) {
          _impl_.level_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:brpc.RtmpInfo.level)
}

// optional string description = 3;
inline bool RtmpInfo::has_description() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void RtmpInfo::clear_description() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.description_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& RtmpInfo::description() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:brpc.RtmpInfo.description)
  return _internal_description();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RtmpInfo::set_description(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.description_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:brpc.RtmpInfo.description)
}
inline std::string* RtmpInfo::mutable_description() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:brpc.RtmpInfo.description)
  return _s;
}
inline const std::string& RtmpInfo::_internal_description() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.description_.Get();
}
inline void RtmpInfo::_internal_set_description(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.description_.Set(value, GetArena());
}
inline std::string* RtmpInfo::_internal_mutable_description() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.description_.Mutable( GetArena());
}
inline std::string* RtmpInfo::release_description() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:brpc.RtmpInfo.description)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.description_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.description_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RtmpInfo::set_allocated_description(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.description_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.description_.IsDefault()) {
          _impl_.description_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:brpc.RtmpInfo.description)
}

// optional double objectEncoding = 4;
inline bool RtmpInfo::has_objectencoding() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void RtmpInfo::clear_objectencoding() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.objectencoding_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline double RtmpInfo::objectencoding() const {
  // @@protoc_insertion_point(field_get:brpc.RtmpInfo.objectEncoding)
  return _internal_objectencoding();
}
inline void RtmpInfo::set_objectencoding(double value) {
  _internal_set_objectencoding(value);
  // @@protoc_insertion_point(field_set:brpc.RtmpInfo.objectEncoding)
}
inline double RtmpInfo::_internal_objectencoding() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.objectencoding_;
}
inline void RtmpInfo::_internal_set_objectencoding(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.objectencoding_ = value;
}

// -------------------------------------------------------------------

// RtmpEmptyObject

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace brpc


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_brpc_2frtmp_2eproto_2epb_2eh
